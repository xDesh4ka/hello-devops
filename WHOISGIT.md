Git — это ==распределенная система управления версиями, которая используется для отслеживания изменений в файлах проекта и совместной работы над ним==. Она позволяет разработчикам фиксировать свою работу локально, а затем синхронизировать ее с удаленным сервером, что делает ее очень гибкой и популярной для проектов любого масштаба. Git помогает сохранять историю всех изменений, что позволяет в любой момент вернуться к предыдущим версиям, а также работать над разными частями проекта параллельно в отдельных ветках.

---
### Установка
- https://git-scm.com/ - загрузить и установить (Windows)
- `$ sudo apt install git`(Linux)

---
### Первоначальная настройка Git

[Git-scm Инструкция по настройке](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%9F%D0%B5%D1%80%D0%B2%D0%BE%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-Git)

Сразу после установки Git необходимо настроить ваше имя и электронную почту. Эти данные привязываются к каждому коммиту и не могут быть изменены позже, поэтому их важно указать правильно. Для этого используйте команды:
```
$ git config --global user.name "Олег Иванов" 
$ git config --global user.email oleg_ivanov@mail.ru
```
Флаг `--global` означает, что настройки применятся ко всем проектам на вашем компьютере. Если для конкретного проекта нужно указать другие данные, выполните эти команды без флага `--global` прямо в папке с проектом.

Чтобы посмотреть текущие настройки Git, используйте команду:
```
$ git config --list
```
Она выведет все найденные параметры, например:
```
user.name=Олег Иванов
user.email=oleg_ivanov@mail.ru
color.status=auto 
color.branch=auto
```
Обратите внимание: некоторые параметры могут повторяться, так как Git считывает настройки из разных файлов (например, `/etc/gitconfig` и `~/.gitconfig`). В этом случае действует последнее значение для каждого ключа.

Если нужно узнать значение конкретного параметра, используйте:
```
$ git config user.name
```

### Инициализация Git-репозитория

Обычно вы получаете репозиторий Git одним из двух способов:
1. Вы можете взять локальный каталог, который в настоящее время не находится под версионным контролем, и превратить его в репозиторий Git, либо
2. Вы можете _клонировать_ существующий репозиторий Git из любого места.
В обоих случаях вы получите готовый к работе Git репозиторий на вашем компьютере.

#### Создание репозитория 
Создание репозитория в существующей папке:  
Перейдите в каталог проекта и выполните:

```
$ git init
```

Это создаст скрытую папку `.git` для хранения структуры репозитория. Чтобы добавить текущие файлы под контроль версий:
```
$ git add readme.md 
$ git commit -m "Мой первый коммит в репу"
```
#### Клонирование репозитория:  
Чтобы получить копию существующего проекта, используйте `git clone <url>`:
```
$ git clone https://github.com/libgit2/libgit2
```

Команда создаст одноимённую папку с полной историей проекта. Для другого имени папки:
```
$ git clone https://github.com/libgit2/libgit2 mylibgit
```

### Создание и работа с ветками

Ветки в Git позволяют работать над разными функциями или исправлениями параллельно, не влияя на основную версию кода.

Создать новую ветку можно командой:
```$ git branch <имя-ветки>```

Эта команда создаст ветку, но останется в текущей. Чтобы сразу создать и перейти на новую ветку, используйте:
```$ git checkout -b <имя-ветки>```

Например, для создания рабочей ветки для новой функции:
```$ git checkout -b feature-branch```

Для переключения между существующими:
```$ git checkout <имя-ветки>```

Список всех локальных веток можно получить командой:
```$ git branch```
Текущая ветка отмечается символом `*`.

После переключения на ветку можно добавлять файлы и коммитить изменения как обычно:
```$ git add . $ git commit -m "Описание изменений"```

Таким образом можно изолировать работу над различными задачами, легко переключаться между ними и впоследствии сливать изменения в основную ветку.


### Слияние веток и разрешение конфликтов

Когда работа над задачей в отдельной ветке завершена, изменения нужно интегрировать в основную ветку проекта. Обычно это делается с помощью команды `git merge`.
Для слияния сначала переключитесь на основную ветку, убедитесь, что у вас последние обновления с удаленного репозитория:
`$ git pull`

Теперь можно выполнить слияние ветки с новыми изменениями:
`$ git merge feature-branch`

Git попробует автоматически объединить изменения. Если изменения в разных файлах или строках, слияние пройдет успешно и будет создан коммит слияния, имеющий двух родителей.

Если изменения в одной и той же строке затрагивались в обеих ветках, возникнет конфликт. Его появление Git покажет в выводе merge и в `$ git status` вы увидите список конфликтных файлов.

Чтобы разрешить конфликт, откройте конфликтующий файл и вручную выберите нужный вариант изменений, убрав метки конфликтов (`<<<<<<<`, `=======`, `>>>>>>>`). После редактирования добавьте исправленный файл в индекс: `$ git add <файл>`

Завершите слияние коммитом:
`$ git commit`

Если в процессе слияния вы передумали или столкнулись с непредвиденными ошибками, можете отменить слияние и вернуть ветку к исходному состоянию командой:
`$ git merge --abort`

Таким образом, слияние с обработкой конфликтов позволяет аккуратно интегрировать параллельную работу нескольких разработчиков или нескольких потоков разработки в одну основную ветку.

## Работа с отложенными изменениями и история коммитов

При разработке может возникнуть ситуация, когда в рабочем каталоге есть незавершённые изменения, но необходимо срочно переключиться на другую задачу или ветку. Для этого используют команду `git stash`.

Чтобы временно сохранить текущие изменения и очистить рабочую директорию, выполните:
`$ git stash`

Git сохранит все незафиксированные изменения (включая индексированные и неиндексированные) во внутреннее хранилище, возвращая проект к последнему коммиту.

Для просмотра списка сохранённых отложенных изменений используйте:
`$ git stash list`

Чтобы вернуть изменения обратно в рабочую директорию и удалить их из стэша, выполните:
`$ git stash pop`

Если нужно применить изменения, но сохранить их в стэше, используйте:
`$ git stash apply`

Для очистки стэша от неактуальных изменений применяют:
`$ git stash drop`

или полностью очистить все отложенные изменения:
`$ git stash clear`

Для упрощения истории коммитов используется команда `git rebase`. Она позволяет "перенести" коммиты одной ветки на другую, сделав историю более последовательной и линейной. Однако при использовании rebase следует быть осторожным, особенно если ветка уже была опубликована в общем репозитории, чтобы избежать проблем при дальнейшем слиянии.

Таким образом, `git stash` помогает временно отложить изменения без коммита, а `git rebase` — сделать историю коммитов более чистой и понятной.

### Пул реквесты (Pull Request)

Пул-реквест — это запрос на интеграцию сделанных изменений из одной ветки в другую, обычно из ветки с новой функцией или исправлением в основную ветку проекта. Это способ уведомить команду о том, что работа над задачей готова к проверке и слиянию.

Процесс создания пул-реквеста обычно выглядит так:
1. Разработчик создает отдельную ветку и вносит в неё необходимые изменения, коммитит их локально.
2. Затем ветка пушится в удалённый репозиторий (например, на GitHub или Bitbucket).
3. Создается пул-реквест — специальный запрос на слияние изменений в основную ветку (например, `main` или `master`).
4. Члены команды или ответственные за проект проводят код-ревью — проверяют изменения, оставляют комментарии и могут попросить доработать код. 
5. После одобрения пул-реквест сливают в основную ветку, закрывая запрос.

Пул-реквесты важны тем, что позволяют структурировать процессы командной разработки - они обеспечивают контроль качества через ревью, позволяют обсуждать и улучшать код до слияния, изолируют изменения до их готовности и снижают риски ошибок в основном коде.


## ## Задание на практику

1. Создайте репозиторий в GitHub (или в другом месте).
2. Создайте новую ветку `feature/TASK-123` от актуальной ветки `main`.
3. Внесите правки, добавьте новый файл с вашим ФИО и группой. Сделайте еще 2 любых коммита.
4. Параллельно создайте другую ветку `bugfix/TASK-3321` от `main`.
5. Внесите изменения в тот же файл, где делали изменения в `feature/TASK-123`, но в другие строки. Сделайте еще 2 коммита.
6. **Находясь в ветке `bugfix/TASK-3321`, начните вносить новые изменения (но не коммитьте их). Затем используйте `git stash`, чтобы временно сохранить эти изменения. Переключитесь на ветку `feature/TASK-123`, выполните какие-то действия (например, просмотр файлов), затем вернитесь в `bugfix/TASK-3321` и восстановите изменения командой `git stash pop`.**
7. Запушьте обе ветки в удалённый репозиторий.
8. Попробуйте слить ветку `feature/TASK-123` в `main` локально.
9. Попытайтесь слить ветку `bugfix/TASK-3321` в `main`. Если возникнет конфликт, разрешите его вручную.
10. Запушьте с разрешенным конфликтом изменения в `main`.
11. Создайте пул-реквест для ветки `bugfix/TASK-3321` в удалённом репозитории и опишите, какие изменения были сделаны и как разрешались конфликты. В Reviewers пул-реквеста добавьте преподавателя или одногруппника.
12. После одобрения пул-реквеста слейте ветку в `main` через веб-интерфейс.

---

[xDesh4ka](https://github.com/xDesh4ka) 
